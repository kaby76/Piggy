#include "clang/ASTMatchers/Dynamic/VariantValue.h"
#include "clang/Basic/LLVM.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/Twine.h"
#include "llvm/Support/raw_ostream.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/ASTMatchers/Dynamic/Parser.h"
#include "clang/Frontend/TextDiagnostic.h"
#include "clang/Basic/CharInfo.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/StringSwitch.h"
#include "libclang/CXTranslationUnit.h"
#include <set>
#include <string>
#include <vector>
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/Tooling/Tooling.h"
#include <iostream>


struct CollectBoundNodes : clang::ast_matchers::MatchFinder::MatchCallback {
    std::vector<clang::ast_matchers::BoundNodes> &Bindings;
    CollectBoundNodes(std::vector<clang::ast_matchers::BoundNodes> &Bindings) : Bindings(Bindings) {}
    void run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override {
        Bindings.push_back(Result.Nodes);
    }
};
static llvm::cl::extrahelp CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage);
static llvm::cl::OptionCategory ClangQueryCategory("clang-query options");

static llvm::cl::list<std::string> Commands("c", llvm::cl::desc("Specify command to run"),
                                            llvm::cl::value_desc("command"),
                                            llvm::cl::cat(ClangQueryCategory));

static llvm::cl::list<std::string> CommandFiles("f",
                                                llvm::cl::desc("Read commands from file"),
                                                llvm::cl::value_desc("file"),
                                                llvm::cl::cat(ClangQueryCategory));



#if defined(_MSC_VER)
//  Microsoft 
#define EXPORT __declspec(dllexport)
#define IMPORT __declspec(dllimport)
#elif defined(__GNUC__)
//  GCC
#define EXPORT __attribute__((visibility("default")))
#define IMPORT
#else
//  do nothing and hope for the best?
#define EXPORT
#define IMPORT
#pragma warning Unknown dynamic link import/export semantics.
#endif

#ifndef STDCALL
# if defined(_MSC_VER)
#   define STDCALL __stdcall
# else
#   define STDCALL
# endif
#endif


static char * search_string;
static std::list<char*> include_dirs;
static std::list<char*> include_files;
std::vector<std::unique_ptr<clang::ASTUnit>>::iterator cur_ast;
std::vector<clang::ast_matchers::BoundNodes>::iterator MI;
clang::ast_matchers::MatchFinder Finder;
std::vector<clang::ast_matchers::BoundNodes> Matches;
std::vector<std::unique_ptr<clang::ASTUnit>> ASTs;

EXPORT CXCursor* Search(char * pattern, CXTranslationUnit tu)
{
	clang::ASTUnit *CXXUnit = clang::cxtu::getASTUnit(tu);

	// Get Matcher.
	clang::ast_matchers::dynamic::Diagnostics Diag;
	llvm::StringMap<clang::ast_matchers::dynamic::VariantValue> NamedValues;
	llvm::Optional<clang::ast_matchers::internal::DynTypedMatcher> Matcher
		= clang::ast_matchers::dynamic::Parser::parseMatcherExpression(
			StringRef(pattern),
			nullptr, &NamedValues, &Diag);
	if (!Matcher)
		return nullptr;

	CollectBoundNodes Collect(Matches);
	llvm::Optional<clang::ast_matchers::internal::DynTypedMatcher> M = Matcher->tryBind("root");
	clang::ast_matchers::internal::DynTypedMatcher MaybeBoundMatcher = *M;
	Finder.addDynamicMatcher(MaybeBoundMatcher, &Collect);

	clang::ASTUnit* ast = clang::cxtu::getASTUnit(tu);
	Finder.matchAST(ast->getASTContext());
	int count = Matches.size();
	CXCursor* result = (CXCursor*)malloc((count + 1) * sizeof(CXCursor));
	for (std::vector<clang::ast_matchers::BoundNodes>::iterator MI = Matches.begin(), ME = Matches.end(); MI != ME; ++MI) {
		for (std::map<std::basic_string<char>, clang::ast_type_traits::DynTypedNode>::const_iterator
			     BI = MI->getMap().begin(), BE = MI->getMap().end(); BI != BE;
			++BI) {
			{
				clang::ast_type_traits::DynTypedNode x = BI->second;
				clang::SourceRange R = x.getSourceRange();
			}
		}
	}
}

